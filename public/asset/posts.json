[{"name":"状压 DP","text":"思想\n\n将原本需要的多个状态使用二进制 bitmark 压缩成一个状态\nbitmark\n\n单个元素访问:\n1 &lt;&lt; (a - 1)\n\n包含所有元素的集合:\n(1 &lt;&lt; n) - 1\n\n最小元素:\nlowbit(s)\n\n常用顺序\n\n\n遍历状态集合\n\n遍历元素\n\n转移\n\n\n\n\n\n"},{"name":"滑动窗口","text":"滑动窗口\n前置知识\n\n\n[[单调队列]]\n\n定义\n\n$k$ = 窗口的大小\n过程\n\n\n先遍历数组的前 $k-1$ 项，入队\n再从 $k$ 遍历到 $n$\n\n入队\n出队窗口范围外的内容\n\n\n\n"},{"name":"整除分块","text":"结论\n\n对于常数 $n$，使得式子\n$$\n\\left\\lfloor\\dfrac ni\\right\\rfloor=\\left\\lfloor\\dfrac nj\\right\\rfloor\n$$\n成立且满足 $i\\leq j\\leq n$ 的 $j$ 值最大为 $\\left\\lfloor\\dfrac n{\\lfloor\\frac ni\\rfloor}\\right\\rfloor$，即值 $\\left\\lfloor\\dfrac ni\\right\\rfloor$ 所在块的右端点为 $\\left\\lfloor\\dfrac n{\\lfloor\\frac ni\\rfloor}\\right\\rfloor$。\n证明\n\n对于这个块中的任意一个数 x，应当满足 $\\lfloor nx \\rfloor=k$，即 $n=xk+r (0 \\leq r&lt;x)$\n当 $n,k$\n已知时，只要确定 $x$，就有一个 $r$ 与之对应。\n$$n=xk+r$$\n$$n≥xk$$\n$$x≤nk$$\n即 $x$ 的最大值为 $\\lfloor nk\\rfloor$\n即 $r=\\left\\lfloor\\dfrac n{\\lfloor\\frac ni\\rfloor}\\right\\rfloor$\n"},{"name":"数位 DP","text":"思想\n\n数位，代表权值和下标\n记录完整数位\n过程\n\nint dfs(x, tag, flag):\n\tif x -&gt; 边界:\n\t\treturn tag\n\tif flag = 0 且 f 存在:\n\t\treturn f\n\tmaxcnt = 9\n\tif flag:\n\t\tmaxcnt = a[x]\n\tfor 0 ~ maxcnt:\n\t\tif ...:\n\t\t\tdfs\n\n"},{"name":"双向搜索","text":"Meet in the middle\n过程\n\n搜索\n\n将搜索过程分为两半\n当结束后，将结果记录\n\n合并\n\n对结果进行排序和去重\n遍历其中一个，二分查找这个结果需要的另一个结果\n\n如果存在，那么记录答案\n\n\n\n"},{"name":"单调队列优化多重背包","text":"前置知识\n\n\n[[单调队列]]\n\n过程\n\n设 $f_{i,j}$ 表示前 $i$ 个物品装入承重为 $j$ 的背包的最大价值，朴素的转移方程为\n$ f_{i,j}=\\max_{k=0}^{k_i}(f_{i-1,j-k\\times w_i}+v_i\\times k) $\n时间复杂度 $O(W\\sum k_i)$ 。\n考虑优化 $f_i$ 的转移。为方便表述，设\n$g_{x,y}=f_{i,x\\times w_i+y},g’{x,y}=f{i-1,x\\times w_i+y}$ ，其中 $0\\le y \\lt w_i$ ，则转移方程可以表示为：\n$ g_{x,y}=\\max_{k=0}^{k_i}(g’_{x-k,y}+v_i\\times k) $\n设\n$G_{x,y}=g’{x,y}-v_i\\times x$ 。则方程可以表示为：\n$ g{x,y}=\\max_{k=0}^{k_i}(G_{x-k,y})+v_i\\times x $\n这样就转化为一个经典的单调队列优化形式了。 $G_{x,y}$ 可以 $O(1)$ 计算，因此对于固定的 $y$ ，我们可以在\n$O\\left( \\left\\lfloor \\dfrac{W}{w_i} \\right\\rfloor \\right)$ 的时间内计算出 $g_{x,y}$ 。因此求出所有 $g_{x,y}$ 的复杂度为\n$O\\left( \\left\\lfloor \\dfrac{W}{w_i} \\right\\rfloor \\right)\\times O(w_i)=O(W)$ 。这样转移的总复杂度就降为 $O(nW)$ 。\n在实现的时候，我们需要先枚举 $y$ ，这样才能保证枚举 $x$ 的时候利用单调队列进行优化，而单调队列中存储的是 $x-k$ ，并不存储 $k$ ，这样使用的时候需要通过 f[last][q.front() * w[i] + y] - q.front() * v[i] 获取对应的 $G_{x-k,y}$ ，不难发现 $x-k\\in [x - k_i,x]$ ，因此在枚举 $x$ 的时候，我们需要删除队列中不在这个范围内的元素。\n"},{"name":"单调队列","text":"定义\n\nq[n]或deque&lt;int&gt; q：存储队列的内容的下标\n\n[!NOTE]\n为什么存储的是下标而不是值?\n因为存储下标可以在滑动窗口中省去site数组\n\n过程\n\n入队\n\n从队顶往下遍历，将小于这个数的数全部出队\n将该数入队\n\n查询\n直接读取队顶即可\n"},{"name":"单调栈","text":"单调栈\n定义\n\nstack&lt;int&gt; stk：用来存放单调栈的内容\n过程\n\n插入\n\n从栈顶往下遍历，将小于这个数的数全部弹出\n插入该数\n\n读取\n直接读取栈顶即可\n"},{"name":"互不侵犯","text":"算法\n\n[[状压 DP]]\n状态设计\n\n$f_{i,j,k}$ = 前 $i$ 行取的状态为 $j$ 使用 $k$ 个国王的情况数\n$j$ 为 bitmark\n$i$  可压缩\n状态转移\n\n$f_{i,j,k}=\\sum f_{i-1,x,k-cnt(x)}$\n实现\n\nQ1: 如何判断两行是否可行？\n这里有三种情况不可以转移\n\n两行中有国王的列相同\n这时我们可以使用与运算判断，因为与运算不为零意味着两个状态集合中有相同的位置是一，所以 pass 掉。\n两行中有国王能斜着攻击\n- 左下\n先右移一位，使它与可能一相同，再用可能一的方法判断\n- 右下\n与左下同理。\n\n"},{"name":"ST表","text":"ST 表\n定义\n\n$f_{i,j}$ = 区间 $[i,i+2^j-1]$ 的最大值\n\n[!NOTE]\n为什么是 $2^j-1$ 而不是 $2^j$ 呢\n因为需要支持区间长度为 $0$ 的情况。\n\n实现\n\n预处理求 $f_{i,j}$\n\n$f_{i,0}=a_i$\n$f_{i,j}=\\max(f_{i,j-1},f_{i+2^{j-1},j-1})$\n\n求区间最大值\n\n\n求出区间内最大的 $2^x$ 长度中的 $x$\n\n\n将区间分成两份：$[l,2^x-1]$，$[r-(2^x-1),r]$\n\n[!NOTE]\n为什么要减$1$?\n因为 $f$ 中的 $j$ 代表 $2^j-1$\n\n两份分别对应 $f_{l,x}$ 和 $f_{r-(2^x-1),x}$\n对两份求 $\\max$ 即可\n\n\n"},{"name":"LCA","text":"LCA\n定义\n\n$fa_{u,i}$ = $u$ 的第 $2^{i}$ 个祖先\n$dep_{u}$ = $u$ 的深度\n过程\n\n\n调整两个节点到同一深度。\n一直往上跳转\n\n实现\n\n预处理求 $fa$\ndfs(u, father):\n\n$fa_{u,0} = father$\n$fa_{u,i} = fa_{fa_{u, i-1},i-1}$\n$dep_{0} = 0$\n$dep_{u} = dep_{father}+1$\n\n求 $lca$\n\n交换 $u,v$ ，使 $dep_u &lt; dep_v$\n通过将 $dep_v-dep_u$ 进行二进制拆分，将 $u$ 和 $v$ 向上跳跃到同一高度\n特判 $x=y$\n循环枚举 $i$ ，继续向上跳跃\n\n"},{"name":"KMP","text":"KMP\n定义\n\n$next_i$ = 到 $i$ 为止的字串真前缀与真后缀最大相同的前缀位置\n$now$ = 当前已匹配个数\n$cur$ = 模式串当前字符位置\n过程\n\n匹配模式串\n\n$now=0$\n$cur=1$\n\n\n检查主串 $cur$ 的位置与模式串 $now+1$ 的位置是否匹配\n\n如果匹配\n\n$now=now+1$\n$cur=cur+1$\n\n\n如果失配\n\n如果 $now \\neq 0$\n$now=next_{now}$\n如果 $now=0$\n$cur=cur+1$\n\n\n\n\n重复执行步骤1，直到 $now$ 等于模式串长度或当前字符走到末尾\n\n求 $next$\n\n$next_1=0$\n$now=0$\n$cur=1$\n\n\n检查主串 $cur+1$ 的位置与模式串 $now+1$ 的位置是否匹配\n\n如果匹配\n\n$next_{cur+1}=now+1$\n$now=now+1$\n$cur=cur+1$\n\n\n如果失配\n\n如果 $now \\neq 0$\n$now=next_{now}$\n如果 $now=0$\n$next_{cur+1}=0$\n$cur=cur+1$\n\n\n\n\n重复执行步骤1，直到 $now$ 等于模式串长度或当前字符走到末尾\n\n"},{"name":"Bomb","text":"算法\n\n[[数位 DP]]\n过程\n\nint dfs(x, tag, flag):\n if x -&gt; 边界:\n  return tag\n if flag = 0 且 f 存在:\n  return f\n maxcnt = 9\n if flag:\n  maxcnt = a[x]\n for 0 ~ maxcnt:\n  if ...:\n   dfs\n\n边界\nx == 0\n取完\n$f$数组\n$f_{i,j}$ = 取 $i$ 位，$tag$ 为 $j$ 的答案\n如果无限制则记录\n分类\n\n\ni == 9 &amp;&amp; tag == 1\n那么dfs(x - 1, 2, flag &amp;&amp; i == maxcnt)\n\n\ni == 4\n先定义tmp为下一个tag\n\n当前tag为$2$\ntmp = 2\n否则\ntmp = 1\n最后再dfs(x - 1, tmp, flag &amp;&amp; i == maxcnt)\n\n\n\ni == 其他数字\n直接dfs(x - 1, tag, flag &amp;&amp; i == maxcnt)\n\n\n"}]